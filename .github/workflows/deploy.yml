# =============================================================================
# CO.RA.PAN Production Deployment Workflow
# =============================================================================
#
# This workflow automatically deploys the application to the production server
# (marele.online.uni-marburg.de) when code is pushed to the main branch.
#
# The deployment runs on a self-hosted GitHub Actions runner installed on the
# production server itself. The runner executes scripts/deploy_prod.sh which:
#   - Updates the code from Git
#   - Starts the stack via docker-compose.prod.yml (code-only)
#   - Verifies runtime-first mounts
#
# Prerequisites on the server:
#   - GitHub self-hosted runner configured and running
#   - Docker installed (docker-compose v1)
#   - /srv/webapps/corapan runtime directories set up
#   - passwords.env configured in /srv/webapps/corapan/config/
#   - data/media synced via rsync (not part of this workflow)
#
# =============================================================================

name: Deploy to Production

on:
  push:
    branches:
      - main

  # Allow manual trigger from GitHub UI
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to marele.online.uni-marburg.de
    runs-on: self-hosted

    steps:
      - name: Deploy corapan-webapp
        run: |
          cd "${GITHUB_WORKSPACE}"
          bash scripts/deploy_prod.sh

      - name: Verify deployment
        run: |
          # Wait a moment for the container to fully start
          sleep 10

          CONTAINER_NAME="corapan-web-prod"
          RUNTIME_ROOT="/srv/webapps/corapan/runtime/corapan"

          # Check if container is running
          if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "✓ Container ${CONTAINER_NAME} is running"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          else
            echo "✗ Container ${CONTAINER_NAME} is not running!"
            docker logs "${CONTAINER_NAME}" 2>&1 | tail -50
            exit 1
          fi

          # Verify runtime-first mounts
          MOUNTS=$(docker inspect "${CONTAINER_NAME}" --format '{{range .Mounts}}{{println .Destination " <- " .Source}}{{end}}' | sort)
          echo "${MOUNTS}"

          EXPECTED_MOUNTS=(
            "/app/data <- ${RUNTIME_ROOT}/data"
            "/app/media <- ${RUNTIME_ROOT}/media"
            "/app/logs <- ${RUNTIME_ROOT}/logs"
            "/app/config <- ${RUNTIME_ROOT}/config"
          )

          for mount in "${EXPECTED_MOUNTS[@]}"; do
            if ! echo "${MOUNTS}" | grep -Fxq "${mount}"; then
              echo "✗ Mount mismatch detected: ${mount}"
              exit 1
            fi
          done

          # Optional: health check
          curl -fsS http://127.0.0.1:6000/health > /dev/null
          echo "✓ Health check passed"
