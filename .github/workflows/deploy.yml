# =============================================================================
# CO.RA.PAN Production Deployment Workflow
# =============================================================================
#
# This workflow automatically deploys the application to the production server
# (marele.online.uni-marburg.de) when code is pushed to the main branch.
#
# The deployment runs on a self-hosted GitHub Actions runner installed on the
# production server itself. The runner executes the deploy_prod.sh script which:
#   - Updates the code from Git
#   - Builds a new Docker image
#   - Restarts the container with new image
#   - Runs database migrations
#
# Prerequisites on the server:
#   - GitHub self-hosted runner configured and running
#   - docker-compose (v1) installed
#   - /srv/webapps/corapan/{app,runtime/corapan} directories set up
#   - passwords.env configured with required environment variables
#   - data/media synced to /srv/webapps/corapan/runtime/corapan/ (not part of this workflow)
#
# IMPORTANT: Production uses runtime-first mounts via docker-compose.prod.yml.
# Legacy mounts (/srv/webapps/corapan/{data,media,logs}) are NOT supported.
# =============================================================================

name: Deploy to Production

on:
  push:
    branches:
      - main

  # Allow manual trigger from GitHub UI
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to marele.online.uni-marburg.de
    runs-on: self-hosted

    steps:
      - name: Deploy corapan-webapp
        run: |
          cd /srv/webapps/corapan/app
          bash scripts/deploy_prod.sh

      - name: Verify deployment
        run: |
          # Wait a moment for the container to fully start
          sleep 10
          
          # Check if container is running (must match docker-compose.prod.yml container_name)
          CONTAINER_NAME="corapan-web-prod"
          if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "✓ Container ${CONTAINER_NAME} is running"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          else
            echo "✗ Container ${CONTAINER_NAME} is not running!"
            docker logs "${CONTAINER_NAME}" 2>&1 | tail -50
            exit 1
          fi
          
          # Verify runtime-first mounts are correct
          echo ""
          echo "Verifying runtime-first mounts..."
          MOUNTS=$(docker inspect "${CONTAINER_NAME}" --format '{{range .Mounts}}{{println .Destination "<-" .Source}}{{end}}' | sort)
          echo "${MOUNTS}"
          
          # Check critical mounts
          if echo "${MOUNTS}" | grep -q "/app/data <- /srv/webapps/corapan/runtime/corapan/data"; then
            echo "✓ /app/data mount is correct (runtime-first)"
          else
            echo "✗ /app/data mount is WRONG! Expected: /srv/webapps/corapan/runtime/corapan/data"
            exit 1
          fi
          
          if echo "${MOUNTS}" | grep -q "/app/media <- /srv/webapps/corapan/runtime/corapan/media"; then
            echo "✓ /app/media mount is correct (runtime-first)"
          else
            echo "✗ /app/media mount is WRONG! Expected: /srv/webapps/corapan/runtime/corapan/media"
            exit 1
          fi
          
          if echo "${MOUNTS}" | grep -q "/app/logs <- /srv/webapps/corapan/runtime/corapan/logs"; then
            echo "✓ /app/logs mount is correct (runtime-first)"
          else
            echo "✗ /app/logs mount is WRONG! Expected: /srv/webapps/corapan/runtime/corapan/logs"
            exit 1
          fi
          
          echo "✓ All mounts verified successfully!"
