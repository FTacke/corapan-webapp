<!-- CQL Guide Modal (MD3 overlay) -->
<div id="cql-guide-overlay" class="md3-dialog-overlay" aria-hidden="true">
  <div id="cql-guide-dialog" class="md3-dialog md3-dialog--large md3-dialog--advanced" role="dialog" aria-modal="true" aria-labelledby="cql-guide-title" tabindex="-1">
    <div class="md3-dialog__container">
      <div class="md3-dialog__header">
        <span class="material-symbols-rounded md3-dialog__icon">info</span>
        <h2 class="md3-dialog__title" id="cql-guide-title">Guía de construcción de consultas CQL mediante un prompt</h2>
      </div>
      <div class="md3-dialog__content">
        <p class="md3-body-medium md3-text-variant">
          Sobre la sintaxis de Blacklab-CQL véase <a href="https://inl.github.io/BlackLab/corpus-query-language.html" target="_blank" rel="noopener noreferrer" class="md3-link">aquí</a>.
        </p>
        <div class="md3-prompt-container">
          <p class="md3-prompt-title">Prompt sugerido para generar consultas CQL en CORAPAN (BlackLab)</p>
          <p class="md3-prompt-subtitle">Copia y pega este prompt en el modelo de IA generativa y luego añade tu descripción al final:</p>
          <div class="md3-code-block md3-full-width">
            <pre class="highlight"><code id="cql-guide-prompt" class="language-plaintext">Actúa como generador de consultas CQL para un corpus de español hablado llamado CORAPAN, indexado en BlackLab.

El corpus está anotado con los siguientes atributos a nivel de token (dentro de corchetes `[...]` en CQL):

* `word`   → forma tal como aparece en la transcripción
* `norm`   → forma normalizada (por ejemplo, en minúsculas)
* `lemma`  → lema
* `pos`    → categoría gramatical (UD POS: `NOUN`, `VERB`, `ADJ`, `ADV`, `PRON`, `DET`, `ADP`, `SCONJ`, `CCONJ`, `PART`, `AUX`, etc.)
* `tense`  → tiempo verbal morfológico (por ejemplo: `"Pres"`, `"Past"`, `"Fut"`)
* `mood`   → modo verbal (por ejemplo: `"Ind"`, `"Subj"`, `"Imp"`)
* `person` → persona gramatical (`"1"`, `"2"`, `"3"`)
* `number` → número gramatical (`"Sing"`, `"Plur"`)
* `aspect` → aspecto verbal (si está presente)
* `PastType`   → subtipo de pasado, ya en inglés, derivado de reglas específicas del corpus. Valores posibles, si existen en el token:

  * `"simplePast"`
  * `"presentPerfect"`
  * `"pastPerfect"`
  * `"futurePerfect"`
  * `"conditionalPerfect"`
  * `"otherCompoundPast"`
  * `"otherPast"`
* `FutureType` → subtipo de futuro analítico (construcciones tipo *ir a + infinitivo*), también en inglés. Valores posibles, si existen en el token:

  * `"periphrasticFuture"` (ir a + INF con auxiliar en presente)
  * `"periphrasticFuturePast"` (ir a + INF con auxiliar en pasado, futuro en el pasado)
* `tokid`  → identificador único de cada token

Los campos `PastType` y `FutureType` **no** proceden directamente del etiquetador morfológico, sino que son clasificaciones derivadas a partir de la combinación de `tense`, `morph`, auxiliares y participios. Se consultan como cualquier otro atributo de token y se pueden combinar con `lemma`, `pos`, `tense`, etc.

Algunos ejemplos de uso:

* `[pos="VERB" & PastType="simplePast"]`
  → verbos en pretérito perfecto simple (pretérito indefinido).

* `[pos="VERB" & PastType="presentPerfect"]`
  → verbos en pretérito perfecto compuesto (*haber* + participio).

* `[pos="VERB" & PastType="pastPerfect"]`
  → verbos en pluscuamperfecto.

* `[pos="VERB" & FutureType="periphrasticFuture"]`
  → futuros perifrásticos del tipo *ir a + infinitivo* con auxiliar en presente.

* `[pos="VERB" & FutureType="periphrasticFuturePast"]`
  → futuros perifrásticos en el pasado (*iba a + infinitivo*, etc.).

* `[lemma="ir" & pos="VERB" & FutureType="periphrasticFuture"]`
  → formas de *ir* que participan en futuros perifrásticos.

Además, puedes usar metadatos de documento/segmento con BlackLab (por ejemplo mediante `within`), como:

* `country_code` → código de país/variedad (por ejemplo `ARG`, `ESP`, `ARG-CBA`, `ESP-SEV`, etc.)
* `file_id`      → identificador de archivo
* `date`         → fecha de la grabación/transcripción
* `radio`        → indica si el texto procede o no de radio (según cómo esté codificado)
* `city`         → ciudad (si está disponible)
* `sentence_id`, `utterance_id` → identificadores de oración y enunciado

Tu tarea:

1. Léeme la descripción en lenguaje natural que te daré.

2. Genera **solo** una consulta CQL válida para BlackLab, sin explicaciones ni comentarios.

3. Usa exclusivamente los atributos y metadatos listados arriba.

4. Representa las palabras y rasgos morfológicos con patrones como:

   * `[lemma="hablar"]`
   * `[pos="VERB" & tense="Pres" & person="1" & number="Sing"]`
   * `[pos="VERB" & PastType="simplePast"]` para un verbo en pretérito perfecto simple
   * `[pos="VERB" & PastType="presentPerfect"]` para un verbo en pretérito perfecto compuesto
   * `[pos="VERB" & FutureType="periphrasticFuture"]` para un futuro perifrástico del tipo *ir a + INF*
   * `[pos="ADJ"][pos="NOUN"]` para un adjetivo seguido de un sustantivo

5. Si menciono restricciones de variedad, origen o tipo de texto, exprésalas con metadatos, por ejemplo:

   * `within <country_code="ARG"> [...]`
   * `within <radio="yes"> [...]`

   (ajusta el valor según la codificación real).

6. Usa siempre comillas dobles `"..."` y la sintaxis CQL estándar de BlackLab.

7. Si la descripción es ambigua, elige la interpretación más común en lingüística hispánica, pero **no inventes** atributos que no existan en la lista ni valores de `PastType` o `FutureType` que no hayan sido definidos.

Ahora convierte la siguiente descripción en una consulta CQL precisa para CORAPAN:

«[ESCRIBE AQUÍ TU DESCRIPCIÓN EN ESPAÑOL]»

            
            </code>
            </pre>
          </div>
        </div>
      </div>
      <div class="md3-dialog__actions">
        <button type="button" class="md3-button md3-button--text md3-dialog__close" id="cql-guide-close">Cerrar</button>
        <button type="button" class="md3-button md3-button--filled" id="cql-guide-copy">
          <span class="material-symbols-rounded md3-button__icon" aria-hidden="true">content_copy</span>
          Copiar prompt
        </button>
      </div>
    </div>
  </div>
</div>
