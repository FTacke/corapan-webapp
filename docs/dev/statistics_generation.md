---
title: "Statistics Generation Documentation"
status: active
owner: backend-team
updated: "2025-11-19"
tags: [statistics, blacklab, api, aggregation]
links:
  - ../reference/api-advanced-search.md
---

# Statistics Generation in Advanced Search

This document describes how statistics are generated from search results in the Advanced Search module, including the filtering logic and aggregation strategy.

---

## Overview

Statistics are generated by the `/search/advanced/stats` endpoint in `src/app/search/advanced_api.py`. The process involves:

1.  **Building the Query**: Reconstructing the exact same CQL pattern and document filters used for the search results.
2.  **Fetching Hits**: Retrieving a large sample of hits from BlackLab Server (BLS).
3.  **Aggregation**: Manually aggregating token-level annotations (e.g., `country_code`, `speaker_type`) from the hits in Python.

---

## 1. Query Construction

To ensure statistics match the search results, the `advanced_api.py` uses a shared helper function `build_advanced_cql_and_filters_from_request(args)`.

### Frontend Parameter Collection
The frontend (`initStatsTabAdvanced.js`) collects all active filters from the form using `FormData` to ensure exact parity with the DataTables request. This includes:
- `q` (Query text)
- `mode` (Search mode: forma, lemma, cql, etc.)
- `sensitive` (Case sensitivity)
- `include_regional` (Regional variants toggle)
- **Metadata Filters**: `country_code`, `speaker_type`, `sex`, `speech_mode`, `discourse` (collected as multi-value parameters).

### Logic
- **CQL Pattern**: Generated from the query string (`q`) and search mode (`forma`, `lemma`, etc.).
- **Filters**: Extracted from request parameters (`country_code`, `speaker_type`, etc.).
- **Filter Application**:
    - **Document Metadata**: Applied as a BlackLab filter query (`filter` param).
    - **Token Annotations**: Some metadata (like `speaker_code`) is stored as token annotations and injected directly into the CQL pattern (e.g., `[word="casa" & speaker_code="lib-pf"]`).

---

## 2. Fetching Hits

Since BlackLab Server (v5/Lucene) does not support complex grouped aggregations natively via a single API call for our specific token-level metadata structure, we fetch the raw hits and aggregate them in the application layer.

### Parameters
- **Endpoint**: `/corpora/corapan/hits`
- **Limit**: `MAX_STATS_HITS = 50000` (Hard cap to prevent memory issues)
- **Context**: `wordsaroundhit=0` (We only need the hit itself, not the context)
- **Fields**: We explicitly request the necessary annotations via `listvalues`:
    - `country_code`
    - `speaker_type`
    - `speaker_sex`
    - `speaker_mode`
    - `speaker_discourse`
    - `radio`
    - `city`

### Sampling
If the total number of hits exceeds `MAX_STATS_HITS`, the statistics are generated based on the first 50,000 hits returned by BlackLab. A warning is logged in this case.

---

## 3. Aggregation Strategy

The aggregation is performed in Python using `collections.Counter`.

### Algorithm
1.  Iterate through the fetched hits.
2.  For each dimension (e.g., "Country"):
    *   Extract the value from the hit's `match` data (e.g., `match['country_code']`).
    *   **Note**: BlackLab returns token annotations as lists (one value per token in the hit). We take the **first non-empty value** found in the hit's tokens.
3.  Count occurrences of each unique value.
4.  Calculate proportions (percentage of total hits in the sample).
5.  Sort results by count (descending).

### Dimensions
- **Country**: `country_code` (fallback to `country`)
- **Speaker Type**: `speaker_type`
- **Sex**: `speaker_sex` (fallback to `sex`)
- **Mode**: `speaker_mode` (fallback to `mode`)
- **Discourse**: `speaker_discourse`
- **Radio**: `radio`

---

## Approaches Considered & Constraints

### Why Client-Side Aggregation?
- **Attempt 1 (Native Grouping)**: We tried using BlackLab's `group=field:country_code` parameter.
    - **Issue**: This works for document metadata fields but is less flexible for our token-level annotation structure where metadata is repeated on tokens. It also didn't support the multi-dimensional aggregation we needed in a single pass without multiple API calls.
- **Attempt 2 (Facets)**: Using `facets` param.
    - **Issue**: Similar limitations with token-level annotations in the current index structure.

### Current Solution (Server-Side Python Aggregation)
- **Pros**: Flexible, allows complex logic (e.g., fallbacks, cleaning), single API call to BLS for data.
- **Cons**: Memory usage for large result sets, limited to `MAX_STATS_HITS` sample.

---

## Troubleshooting

### "Statistics ignore filters"
- **Cause**: If the `filter_query` is not correctly passed to the BLS request in `advanced_stats`.
- **Fix**: Ensure `bls_params["filter"] = filter_query` is set. (Fixed in `advanced_api.py`).

### "Limits capped at 3000"
- **Cause**: BlackLab Server configuration (`maxHitsToCount`, `maxHitsToRetrieve`).
- **Fix**: Update `blacklab-server.yaml` to increase these limits (e.g., to 20,000).

